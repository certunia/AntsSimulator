function Ant(x, y, sizeAnts , canvas) {
    const obj = {};
    obj.x = x;
    obj.y = y;
    obj.dx = 0;
    obj.dy = 0;

    // got a piece of food or not
    obj.hasFood  = false;

    // after home or food  is detected -> intensity is 1000
    obj.intensity = 0;
    const intensityFall = -11;


    const ctx = canvas.getContext("2d");
    const ballRadius = sizeAnts;
    const time = 10;// how many iter'ations until it changes its direction
    let iter = 0 ;// counter of iterations
    let angle = getRandomInt( 0 , 360 );
    const speed = 1.5;
    let lastNextPoint;
    let skipNextPoint = false;

    obj.play = function (nextPoint) {
        //redraw
        ctx.beginPath();
        ctx.arc(obj.x, obj.y, ballRadius, 0, Math.PI*2);
        // paint the ant depending on it's status
        if ( obj.hasFood ) {
            ctx.fillStyle = foodColor;
        } else if ( obj.intensity > 0 ) {
            ctx.fillStyle = homeColor;
        } else {
            ctx.fillStyle = antColor;
        }
        ctx.fill();
        ctx.closePath();

        // if it did certain time of steps:
        if (iter === time) {
            iter = 0;

            if ( obj.intensity > 0 ) {
                obj.leavePoint = true;
                obj.intensity += intensityFall;
            }

            skipNextPoint = lastNextPoint?.intensity < nextPoint?.intensity;

            // there is a chance that it will change it's path
            const rand = Math.random();

            if (nextPoint === undefined || skipNextPoint) {
                if ( rand < 0.25 ) {
                    angle += 25;
                } else if ( rand > 0.75 ) {
                    angle -= 25;
                }
            }
        }

        //detection if it goes beyond canvas border
        if(obj.x + obj.dx < ballRadius) {
            obj.x = canvas.width-ballRadius-10;
        }
        else if(obj.x + obj.dx > canvas.width-ballRadius) {
            obj.x = ballRadius;
        }

        if(obj.y + obj.dy > canvas.height-ballRadius+2) {
            obj.y = ballRadius;
        }
        else if ( obj.y + obj.dy < ballRadius-2) {
            obj.y = canvas.height-ballRadius;
        }

        let radians;
        // calculate next coordinates depending on direction angle
        if (nextPoint !== undefined && !skipNextPoint) {
            radians = calcAngleDegrees(nextPoint.x, nextPoint.y);
        } else {
            radians = degreesToRadians(angle);
        }
        obj.x = speed * Math.cos(radians) + obj.x;
        obj.y = speed * Math.sin(radians) + obj.y;

        iter += 1;
        skipNextPoint = false;
    };

    function calcAngleDegrees(nextX, nextY) {
        return Math.atan2( nextY - obj.y, nextX - obj.x);
    }

    function degreesToRadians (degrees) {
        return degrees * ( Math.PI / 180 );
    }

    obj.collisionWithHome = function () {
        obj.intensity = 1000;
        obj.hasFood = false;
    }

    obj.collisionWithFood = function () {
        obj.intensity = 1000;
        obj.hasFood = true;
    }

    return obj;
}



function Grid(canvasW, canvasH, size, canvas) {
    const obj = {};

    obj.columns = canvasW / size;
    obj.rows = canvasH / size;
    obj.intensityFall = -1;

    obj.matrix = new Array(obj.columns);

    // each cell point has foodIntensity, homeIntensity and optionally isHomePoint or isFoodPoint
    for (let i = 0; i < obj.columns; i++) {
        obj.matrix[i] = new Array(obj.rows);

        for (let j = 0; j < obj.rows; j++) {
            obj.matrix[i][j] = { foodIntensity: 0, homeIntensity: 0 };
        }
    }

    const ctx = canvas.getContext("2d");

    // play is basically draw
    obj.play = function () {
        obj.matrix.forEach((column, columnIndex) => {
            column.forEach((row, rowIndex) => {
                if (obj.matrix[columnIndex][rowIndex].isHomePoint) {
                    drawCell(columnIndex, rowIndex, '#e12120');
                } else if (obj.matrix[columnIndex][rowIndex].isFoodPoint) {
                    drawCell(columnIndex, rowIndex, `#16b116`);
                } else if (obj.matrix[columnIndex][rowIndex].homeIntensity > 0) {
                    row.homeIntensity += obj.intensityFall;
                    drawCell(columnIndex, rowIndex, `rgba(250, 250, 250)`); // ${row.homeIntensity}
                } else if (row.foodIntensity > 0) {
                    row.foodIntensity += obj.intensityFall;
                    drawCell(columnIndex, rowIndex, `rgba(250, 250, 0)`); // ${row.foodIntensity}
                }
            });
        });
    }

    obj.addHome = function (column, row, homeRadius) {
        getPointsInRadius(column, row, homeRadius).forEach(point => {
            obj.matrix[point.column][point.row].isHomePoint = true;
        })
    }

    obj.addFood = function (column, row, homeRadius) {
        getPointsInRadius(column, row, homeRadius).forEach(point => {
            obj.matrix[point.column][point.row].isFoodPoint = true;
        })
    }

    obj.addPoint = function (x, y, isFood, intensity) {
        const position = findPosition(x, y);

        if (isFood) {
            obj.matrix[position.column][position.row].foodIntensity = intensity;
        } else {
            obj.matrix[position.column][position.row].homeIntensity = intensity;
        }
    }

    obj.findBestPointInRadius = function (antX, antY, r, hasFood) {
        // first find ant's position in grid
        const antGridPosition = findPosition(antX, antY);

        // then find all points within radius of ant
        const points = getPointsInRadius(antGridPosition.column, antGridPosition.row, r);

        // then find food or home
        if (hasFood) {
            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                if (obj.matrix[point.column][point.row]?.isHomePoint) {
                    return findCoordsOfPixelsCenter(point.column, point.row)
                }
            }
        } else if (!hasFood) {
            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                if (obj.matrix[point.column][point.row]?.isFoodPoint) {
                    return findCoordsOfPixelsCenter(point.column, point.row)
                }
            }
        }

        // and if no food or home is found ant should go to the nearest food or home mark left by other ants
        const bestPointsToGoTo = findBestPoints(points, hasFood);

        if (bestPointsToGoTo.length) {
            const bestPointToGoTo = bestPointsToGoTo.reduce((max, current) => {
                return current.intensity > max.intensity ? current : max;
            }, bestPointsToGoTo[0]);

            return findCoordsOfPixelsCenter(bestPointToGoTo.column, bestPointToGoTo.row);
        }

        return undefined;
    }

    obj.checkCollision = function (x, y, type) {
        const position = findPosition(x, y);

        if (isValidColumnAndRow(position.column, position.row)) {
            return obj.matrix[position.column][position.row][type] ?? false;
        }
    }

    // Find the center of a cell, use it as coordinates of next point for an ant.
    function findCoordsOfPixelsCenter(x, y) {
        const distanceToCenter = parseInt(size / 2);
        return {x: x * size + distanceToCenter, y: y * size + distanceToCenter};
    }

    // check if valid column and row
    function isValidColumnAndRow(column, row) {
        if (Number.isInteger(column) && Number.isInteger(row)) {
            if (column >= 0 && row >= 0 && column < obj.columns && row < obj.rows) {
                return true
            }
        }

        return false;
    }

    // Draw a cell on canvas.
    function drawCell(columnIndex, rowIndex, color) {
        ctx.beginPath();
        ctx.rect(columnIndex * size, rowIndex * size, size, size);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.closePath();
    }

    // Function to check if a cell with food is within an ant's radius.
    function findBestPoints(points, hasFood = false) {
        let arr = [];

        points.forEach(point => {
            const { column, row } = point
            // for home points
            if (hasFood && obj.matrix[column][row].homeIntensity >= 1) {
                arr.push({
                    column,
                    row,
                    intensity: obj.matrix[column][row].homeIntensity
                });
            }
            // for food points
            else if (!hasFood && obj.matrix[column][row].foodIntensity >= 1) {
                arr.push({
                    column,
                    row,
                    intensity: obj.matrix[column][row].foodIntensity
                });
            }
        })

        return arr;
    }

    // Function to get all the points in a gird circle.
    function getPointsInRadius(centerX, centerY, radius) {
        const points = [];

        // TODO check points out of bounds
        for (let x = centerX - radius; x <= centerX + radius; x++) {
            for (let y = centerY - radius; y <= centerY + radius; y++) {
                if (isValidColumnAndRow(x, y)) {
                    // Calculate the distance from the center to the current point (x, y)
                    const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));

                    if (distance <= radius) {
                        points.push({ column: x, row: y });
                    }
                }
            }
        }

        return points;
    }

    // Function find position in a grid according to x and y coordinates.
    const findPosition = function (x, y) {
        const column = parseInt(x / size);
        const row = parseInt(y / size);

        return {
            column,
            row
        };
    }

    return obj;
}

const foodColor = '#16b116';
const homeColor = '#e12120';
const antColor = '#0095DD';


function Ants() {
    const canvas = document.getElementById("myCanvas");
    const canvasH = canvas.height;
    const canvasW = canvas.width;
    const ctx = canvas.getContext("2d");

    const sizeAnts = 3;
    const sizeHome = 10;
    const sizeFood = 8;
    const sizeGrid = 2;

    const howManyFood = 1;
    const howManyAnts = 200;

    const ants = [];
    const antSensitiveRadius = 20;

    const grid = Grid(canvasW, canvasH, sizeGrid, canvas);

    // create home
    grid.addHome( canvasW/2/sizeGrid, canvasH/2/sizeGrid, sizeHome );

    // create ants
    for (let i = 0; i < howManyAnts; i++) {
        const rx = canvasW/2;
        const ry = canvasH/2;

        ants[i] = Ant( rx, ry, sizeAnts, canvas );
    }

    // create food
    // for (let k = 0; k < howManyFood; k++) {
        grid.addFood( 400/sizeGrid, 380/sizeGrid, sizeFood );
    //
    //     // var rx = getRandomInt( 10 , canvasW  - 10 ); // random x
    //     // var ry = getRandomInt( 10 , canvasH - 10 ); // random y
    //     // food[k] = Food( rx, ry, sizeFood, canvas );
    // }

    // make everything move
    setInterval(function () {
        // first we clear canvas
        ctx.clearRect(0, 0, canvasW, canvasH);

        //then we draw everything again
        grid.play();

        ants.forEach((ant) => {
            // todo replace with a clock
            if (ant.leavePoint) {
                ant.leavePoint = false;
                if (ant.hasFood) {
                    grid.addPoint(ant.x, ant.y, true, ant.intensity);
                } else {
                    grid.addPoint(ant.x, ant.y, false, ant.intensity);
                }
            }

            // if ant has food -> find home
            // else find food
            const nextPoint = grid.findBestPointInRadius(ant.x, ant.y, antSensitiveRadius, ant.hasFood);

            // next point can be undefined, then ant will just move randomly
            ant.play(nextPoint);

            // home collision
            if ( grid.checkCollision( ant.x, ant.y, 'isHomePoint' ) ) {
                ant.collisionWithHome();
            }

            if ( grid.checkCollision( ant.x, ant.y, 'isFoodPoint' ) ) {
                ant.collisionWithFood();
            }
        })
    },40);
}

function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min; //Максимум и минимум включаются
}

window.addEventListener('DOMContentLoaded', Ants);
