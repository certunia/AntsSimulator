function Ant(x, y, sizeAnts , canvas) {
    const obj = {};
    obj.x = x;
    obj.y = y;
    obj.dx = 0;
    obj.dy = 0;

    // got a piece of food or not
    obj.hasFood  = false;

    // is it detected home
    obj.homePath = false;

    // found Path to0095DD food
    obj.goToFood = false;

    // when got a food go find home Path
    obj.goToHome = false;

    obj.path = Path();
    obj.canvas = canvas;
    obj.canvas1 = canvas;
    var ctx = obj.canvas.getContext("2d");

    obj.path.addPoint( x, y, obj.canvas); // first path point before play()

    var ballRadius = sizeAnts;
    var time = 10;// how many iter'ations until it changes it's direction
    var iter = 0 ;// counter of iteration
    var angle = getRandomInt( 0 , 360 );
    var speed = 1.5;
    var timePath = 100;
    var iterPath = 0;

    obj.play = function () {
        //redraw
        ctx.beginPath();
        ctx.arc(obj.x, obj.y, ballRadius, 0, Math.PI*2);
        // paint the ant depending on it's status
        if ( obj.hasFood ) {
            ctx.fillStyle = "#16b116";
        }
        else if ( obj.homePath ) {
            ctx.fillStyle = "#e12120";
        }
        else {
            ctx.fillStyle = "#0095DD";
        }
        ctx.fill();
        ctx.closePath();

        // obj.path.play(); // TODO - this line of code makes a mess, need to move path to main function

        // if it did sertain time of steps, there is a chance that it will change it's path
        if (iter === time) {
            leavePoint ( obj.x, obj.y, obj.canvas1);

            iter = 0;

            var rand = Math.random();

            if ( rand < 0.25 ) {
                angle += 25;
            }
            else if ( rand > 0.75 ) {
                angle -= 25;
            }
        }

        //detection if it goes beyond canvas border
        if(obj.x + obj.dx < ballRadius) {
            obj.x = canvas.width-ballRadius-10;
        }
        else if(obj.x + obj.dx > canvas.width-ballRadius) {
            obj.x = ballRadius;
        }

        if(obj.y + obj.dy > canvas.height-ballRadius+2) {
            obj.y = ballRadius;
        }
        else if ( obj.y + obj.dy < ballRadius-2) {
            obj.y = canvas.height-ballRadius;
        }

        // calculate next coordinates depending on direction angle
        var radians = degrees_to_radians(angle);
        obj.x = speed * Math.cos(radians) + obj.x;
        obj.y = speed * Math.sin(radians) + obj.y;

        iter += 1;
        iterPath += 1;

        if ( iterPath === timePath ) {
            // leavePoint();
            iterPath = 0;
        }
    };

    function degrees_to_radians (degrees) {
        return degrees * ( Math.PI / 180 );
    }

    function leavePoint ( x, y, canvas) {
        obj.path.addPoint(x, y, canvas);
    }

    // checks if ant inside some area or collide with something
    obj.checkColision = function ( x, y, radius) {
        if ( obj.x < x + radius) { // right
            if ( obj.x > x - radius) { // left
                if ( obj.y < y + radius ) { // bottom
                    if ( obj.y > y - radius ) { // top
                        return true;
                    }
                }
            }
        }
        else {
            return false;
        }
    };

    return obj;
}





// function Colony( amount ) {
//     const obj = {};
//     obj.amount = amount;
//     obj.ants = [];
//
//     obj.createAnts = function ( amount ) {
//         for (var i of amount ) {
//             obj.ants.push(Ant());
//         }
//     }
//
//     obj.findNextPoint = function () {
//         console.log('asdffdsa');
//     }
//
//     return obj;
// }


function Food(x, y, sizeFood, canvas) {
    const obj = {};

    obj.x = x;
    obj.y = y;

    var ctx = canvas.getContext("2d");

    obj.play = function () {
        ctx.beginPath();
        ctx.arc(obj.x, obj.y, sizeFood, 0, Math.PI * 2);
        ctx.fillStyle = "#0e6b0e";
        ctx.fill();
        ctx.closePath();
    }

    return obj;
}
function Ants() {
    var canvas = document.getElementById("myCanvas");
    var canvasH = canvas.height;
    var canvasW = canvas.width;
    var ctx = canvas.getContext("2d");
    var sizeAnts = 5;
    var sizeHome = 30;
    var sizeFood = 8;

    var howManyFood = 100;
    var food = [];

    var howManyAnts = 30;
    var ants = [];

    var pathsToHome = [];
    var pathsToFood = [];

    // create ants
    for (i = 0; i < howManyAnts; i++) {
        var rx = getRandomInt( 10 , canvasW  - 10 ); // random x
        var ry = getRandomInt( 10 , canvasH - 10 ); // random y

        ants[i] = Ant( rx, ry, sizeAnts, canvas );
    }

    // create food
    for (k = 0; k < howManyFood; k++) {
        food[k] = Food( 100, 100, sizeFood, canvas );

        // var rx = getRandomInt( 10 , canvasW  - 10 ); // random x
        // var ry = getRandomInt( 10 , canvasH - 10 ); // random y

        // food[k] = Food( rx, ry, sizeFood, canvas );
    }


    // make everything move
    setInterval(function () {
        // first we clear field
        ctx.clearRect(0, 0, canvasW, canvasH);

        //then we draw everything again
        ctx.beginPath();
        ctx.arc( canvasW/2 , canvasH/2 , sizeHome, 0, Math.PI*2);
        ctx.fillStyle = "#801716";
        ctx.fill();
        ctx.closePath();

        for (j = 0; j < food.length; j++ ) {
            food[j].play();
        }

        for (i = 0; i < ants.length; i++) {
            ants[i].play();

            // home collision
            if ( ants[i].checkColision( canvasW/2, canvasH/2, sizeHome ) ) {
                ants[i].homePath = true;
                ants[i].goToFood = true;
                ants[i].goToHome = false;
                ants[i].hasFood  = false;
            }

            // food collision
            for (j = 0; j < food.length; j++) {
                if ( ants[i].checkColision( food[j].x, food[j].y, sizeFood ) ) {
                    ants[i].homePath = false;
                    ants[i].goToFood = false;
                    ants[i].goToHome = true;
                    ants[i].hasFood  = true;
                }
            }
        }
    },20);
}

function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min; //Максимум и минимум включаются
}

window.addEventListener('DOMContentLoaded', Ants);



function Path() {
    const obj = {};

    obj.points = [];
    obj.toHome = false;
    obj.toFood = false;

    obj.addPoint = function ( x, y, canvas ) {
       obj.points.push(Point( x, y, canvas ));
    }

    obj.play = function () {
        for ( i = 0; i < obj.points.length; i++ ) {
            obj.points[i].play();
        }
    }

    //////// 1.нужно починить угол и расчет направления

    //////// 2.создаем объект путя который содержит в себе поинты.

    // 3.которые со временем исчезают, может создам временную функцию для них

    // 4.причем этот путь должен создаваться муравьем, значит он должен быть внутри муравья?
    //     или он должен создаваться отдельно в мэйне? <- скорее вот так

    return obj;
}



function Point(x, y, canvas) {
    const obj = {};

    obj.canvas = canvas;
    var ctx = obj.canvas.getContext("2d");

    obj.x = x;
    obj.y = y;

    obj.intensity = 0;

    obj.play = function () {
        ctx.beginPath();
        ctx.arc(obj.x, obj.y, 1, 0, Math.PI*2);
        ctx.fillStyle = "#0e6b0e";
        ctx.fill();
        ctx.closePath();
    }

    return obj;
}
